-- Greg Stitt
-- University of Florida
-- EEL 5934/4930 Reconfigurable Computing

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

use work.user_pkg.all;

entity ctrl is
  port( clk, rst, go : in  std_logic;
        ready        : in   std_logic;
        done         : out std_logic;

        -- control signals used/generated by the datapath
        --count        :  in std_logic_vector(C_MEM_ADDR_WIDTH downto 0);
        load, wen, addr_in_g, addr_out_g  : out std_logic );
end ctrl;

architecture bhv of ctrl is

  type STATE_TYPE is (START, WAIT_0, WAIT_1, INIT, LOOP_COND,
                      RESULT);
  signal state, next_state   : STATE_TYPE;
  -- signal done_s, next_done_s : std_logic;
  signal i      :   std_logic_vector(1 downto 0):= "01";
  signal j      :   std_logic_vector(2 downto 0):=  "100";
  signal target :   std_logic_vector(C_MEM_ADDR_WIDTH downto 0):=   (others=>'0');

begin

  -- state register
  process (clk, rst)
  begin
    if (rst = '1') then
      state  <= START;
      -- done_s    <=  '0';
    elsif (clk = '1' and clk'event) then
      state  <= next_state;
      -- done_s    <=  next_done_s;
    end if;
  end process;

  -- next state logic
  process( go, state,ready )
  begin

    load        <= '-';
    wen         <= '-';
    addr_in_g   <= '-';
    addr_out_g  <= '-';  
    -- next_done_s <= done_s;
    next_state  <= state;

    case state is
      when START =>
        done        <= '0';
        load        <= '0';
        wen         <= '0';
        addr_in_g   <= '0';
        addr_out_g  <= '0';

        if (go = '1') then
          next_state <= INIT;
        end if;

      

      when INIT =>
        done        <= '0';
        load        <= '1';
        wen         <= '0';
        addr_in_g   <= '1';
        addr_out_g  <= '0';

        next_state <= LOOP_COND;

      when LOOP_COND =>
        done        <= '0';
        load        <= '1';
        wen         <= '0';
        addr_in_g   <= '0';
        addr_out_g  <= '0';
        
        if (ready='1') then
            next_state <= RESULT;
        else
            next_state <= LOOP_COND;
        end if;

      when RESULT =>
        done        <= '0';
        load        <= '1';
        wen         <= '1';
        addr_in_g   <= '0';
        addr_out_g  <= '1';
        next_state <= WAIT_0;

      when WAIT_0 =>
        done <='1';
        load        <= '0';
        wen         <= '0';
        addr_in_g   <= '0';
        addr_out_g  <= '0';
        if (go = '0') then
          next_state <= WAIT_1;
        end if;

      when WAIT_1 =>
        done <='1';
        load        <= '0';
        wen         <= '0';
        addr_in_g   <= '0';
        addr_out_g  <= '0';

        if (go = '1') then
            next_state  <= INIT;
        end if;

      when others => null;
    end case;
  end process;

end bhv;
